
# 一、启发思考：寻找子问题
假设 n=9。  
我们要解决的问题是从 0 爬到 9 有多少种不同的方法。  
分类讨论：
1. 如果最后一步爬了 1 个台阶，那么我们得先爬到 8，要解决的问题缩小成：从 0 爬到 8 有多少种不同的方法。
2. 如果最后一步爬了 2 个台阶，那么我们得先爬到 7，要解决的问题缩小成：从 0 爬到 7 有多少种不同的方法。  
   由于这两种情况都会把原问题变成一个和原问题相似的、规模更小的子问题，所以可以用递归解决。

   注 1：从大往小思考，主要是为了方便把递归翻译成递推。从小往大思考也是可以的。  
   注 2：动态规划有「选或不选」和「枚举选哪个」两种基本思考方式。在做题时，可根据题目要求，选择适合题目的一种来思考。本题用到的是「枚举选哪个」。

# 二、递归怎么写：状态定义与状态转移方程

因为要解决的问题都是「从 0 爬到 i」，所以定义 dfs(i) 表示从 0 爬到 i 有多少种不同的方法。  
分类讨论：
1. 如果最后一步爬了 1 个台阶，那么我们得先爬到 i−1，要解决的问题缩小成：从 0 爬到 i−1 有多少种不同的方法。
2. 如果最后一步爬了 2 个台阶，那么我们得先爬到 i−2，要解决的问题缩小成：从 0 爬到 i−2 有多少种不同的方法。  
   由于这两种方法是互相独立的（爬的台阶个数不同），所以根据加法原理，从 0 爬到 i 的方法数等于这两种方法数之和，即

   				`dfs(i)=dfs(i−1)+dfs(i−2)`
递归边界：dfs(0)=1, dfs(1)=1。从 0 爬到 0 有一种方法，即原地不动。从 0 爬到 1 有一种方法，即爬 1 个台阶。
```go
func dfs(i int) int {  
    if i <= 1 { // 递归边界  
       return 1  
    }  
    return dfs(i-1) + dfs(i-2)  
}  
  
func climbStairs(n int) int {  
    return dfs(n)  
}
```
复杂度分析
- 时间复杂度：O(2  n  )。搜索树可以近似为一棵二叉树，树高为 O(n)，所以节点个数为 O(2n  )，遍历搜索树需要 O(2n  ) 的时间。
- 空间复杂度：O(n)。递归需要 O(n) 的栈空间。
# 三、递归 + 记录返回值 = 记忆化搜索
上面的做法太慢了，怎么优化呢？

注意到「先爬 1 个台阶，再爬 2 个台阶」和「先爬 2 个台阶，再爬 1 个台阶」，都相当于爬 3 个台阶，都会从 dfs(i) 递归到 dfs(i−3)。

一叶知秋，整个递归中有大量重复递归调用（递归入参相同）。由于递归函数没有副作用，同样的入参无论计算多少次，算出来的结果都是一样的，因此可以用记忆化搜索来优化：

- 如果一个状态（递归入参）是第一次遇到，那么可以在返回前，把状态及其结果记到一个 memo 数组中。
- 如果一个状态不是第一次遇到（memo 中保存的结果不等于 memo 的初始值），那么可以直接返回 memo 中保存的结果。  
  注意：memo 数组的初始值一定不能等于要记忆化的值！例如初始值设置为 0，并且要记忆化的 dfs(i) 也等于 0，那就没法判断 0 到底表示第一次遇到这个状态，还是表示之前遇到过了，从而导致记忆化失效。一般把初始值设置为 −1。本题由于方案数均为正数，所以可以初始化成 0。
```go
func climbStairs(n int) int {  
    memo := make([]int, n+1)  
    var dfs func(int) int  
    dfs = func(i int) int {  
       if i <= 1 { // 递归边界  
          return 1  
       }  
       p := &memo[i]  
       if *p != 0 { // 之前计算过  
          return *p  
       }  
       res := dfs(i-1) + dfs(i-2)  
       *p = res // 记忆化  
       return res  
    }  
    return dfs(n)  
}
```

复杂度分析
- 时间复杂度：O(n)。由于每个状态只会计算一次，动态规划的时间复杂度 = 状态个数 × 单个状态的计算时间。本题状态个数等于 O(n)，单个状态的计算时间为 O(1)，所以动态规划的时间复杂度为 O(n)。
- 空间复杂度：O(n)。有多少个状态，memo 数组的大小就是多少。
# 四、1:1 翻译成递推
我们可以去掉递归中的「递」，只保留「归」的部分，即自底向上计算。  
具体来说，f[i] 的定义和 dfs(i) 的定义是一样的，都表示从 0 爬到 i 有多少种不同的方法。  
相应的递推式（状态转移方程）也和 dfs 一样：

`f[i]=f[i−1]+f[i−2]`
相当于之前是用递归去计算每个状态，现在是枚举并计算每个状态。

初始值` f[0]=1, f[1]=1`，翻译自递归边界` dfs(0)=1, dfs(1)=1`。

答案为` f[n]`，翻译自递归入口 `dfs(n)`。

```go
func climbStairs(n int) int {  
    f := make([]int, n+1)  
    f[0], f[1] = 1, 1  
    for i := 2; i <= n; i++ {  
       f[i] = f[i-1] + f[i-2]  
    }  
    return f[n]  
}
```

复杂度分析
- 时间复杂度：O(n)。
- 空间复杂度：O(n)。
# 五、空间优化
观察状态转移方程，发现一旦算出` f[i]`，那么` f[i−2]` 及其左边的状态就永远不会用到了。

这意味着每次循环，只需要知道「上一个状态」和「上上一个状态」的 f 值是多少，分别记作 f1​ 和 f0​。它俩的初始值均为 1，对应着 `f[1] 和 f[0]`。

每次循环，计算出新的状态 `newF=f1​+f0`​，那么对于下一轮循环来说：

- 「上上一个状态」就是 f1​，更新 f0​=f1​。
- 「上一个状态」就是 newF，更新 f1​=newF。

最后答案为 f1​，因为最后一轮循环算出的 newF 赋给了 f1​

```go  
func climbStairs(n int) int {  
    f0, f1 := 1, 1  
    for i := 2; i <= n; i++ {  
       f0, f1 = f1, f1+f0  
    }  
    return f1  
}
```  

复杂度分析
- 时间复杂度：O(n)。
- 空间复杂度：O(1)。仅用到若干变量。  


## 最小花费爬楼梯 调用栈图
![image.png](http://cdn.ltq9.top//image-ltq202407311440466.png)
